import { toArray, escapeSelector } from '@unocss/core';
import { createValueHandler, parseCssColor, getStringComponents, colorToString, getStringComponent } from '@unocss/rule-utils';

const PRESET_NAME = "@unocss/preset-wind4";
const passThemeKey = ["DEFAULT", "none"];
const trackedTheme = /* @__PURE__ */ new Set([]);
function themeTracking(key, props = "DEFAULT") {
  const k = `${key}:${toArray(props).join("-")}`;
  if (!trackedTheme.has(k)) {
    trackedTheme.add(k);
  }
}

const directionMap = {
  "l": ["-left"],
  "r": ["-right"],
  "t": ["-top"],
  "b": ["-bottom"],
  "s": ["-inline-start"],
  "e": ["-inline-end"],
  // 'x': ['-left', '-right'],
  // 'y': ['-top', '-bottom'],
  "x": ["-inline"],
  "y": ["-block"],
  "": [""],
  "bs": ["-block-start"],
  "be": ["-block-end"],
  "is": ["-inline-start"],
  "ie": ["-inline-end"],
  "block": ["-block-start", "-block-end"],
  "inline": ["-inline-start", "-inline-end"]
};
const insetMap = {
  ...directionMap,
  x: ["-inset-inline"],
  y: ["-inset-block"],
  s: ["-inset-inline-start"],
  start: ["-inset-inline-start"],
  e: ["-inset-inline-end"],
  end: ["-inset-inline-end"],
  bs: ["-inset-block-start"],
  be: ["-inset-block-end"],
  is: ["-inset-inline-start"],
  ie: ["-inset-inline-end"],
  block: ["-inset-block-start", "-inset-block-end"],
  inline: ["-inset-inline-start", "-inset-inline-end"]
};
const cornerMap = {
  "l": ["-top-left", "-bottom-left"],
  "r": ["-top-right", "-bottom-right"],
  "t": ["-top-left", "-top-right"],
  "b": ["-bottom-left", "-bottom-right"],
  "tl": ["-top-left"],
  "lt": ["-top-left"],
  "tr": ["-top-right"],
  "rt": ["-top-right"],
  "bl": ["-bottom-left"],
  "lb": ["-bottom-left"],
  "br": ["-bottom-right"],
  "rb": ["-bottom-right"],
  "": [""],
  "bs": ["-start-start", "-start-end"],
  "be": ["-end-start", "-end-end"],
  "s": ["-end-start", "-start-start"],
  "is": ["-end-start", "-start-start"],
  "e": ["-start-end", "-end-end"],
  "ie": ["-start-end", "-end-end"],
  "ss": ["-start-start"],
  "bs-is": ["-start-start"],
  "is-bs": ["-start-start"],
  "se": ["-start-end"],
  "bs-ie": ["-start-end"],
  "ie-bs": ["-start-end"],
  "es": ["-end-start"],
  "be-is": ["-end-start"],
  "is-be": ["-end-start"],
  "ee": ["-end-end"],
  "be-ie": ["-end-end"],
  "ie-be": ["-end-end"]
};
const xyzMap = {
  "x": ["-x"],
  "y": ["-y"],
  "z": ["-z"],
  "": ["-x", "-y"]
};
const xyzArray = ["x", "y", "z"];
const basePositionMap = [
  "top",
  "top center",
  "top left",
  "top right",
  "bottom",
  "bottom center",
  "bottom left",
  "bottom right",
  "left",
  "left center",
  "left top",
  "left bottom",
  "right",
  "right center",
  "right top",
  "right bottom",
  "center",
  "center top",
  "center bottom",
  "center left",
  "center right",
  "center center"
];
const positionMap = Object.assign(
  {},
  ...basePositionMap.map((p) => ({ [p.replace(/ /, "-")]: p })),
  ...basePositionMap.map((p) => ({ [p.replace(/\b(\w)\w+/g, "$1").replace(/ /, "")]: p }))
);
const globalKeywords = [
  "inherit",
  "initial",
  "revert",
  "revert-layer",
  "unset"
];
const cssMathFnRE = /^(calc|clamp|min|max)\s*\((.+)\)(.*)/;
const cssVarFnRE = /^(var)\s*\((.+)\)(.*)/;

const numberWithUnitRE = /^(-?\d*(?:\.\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;
const numberRE = /^(-?\d*(?:\.\d+)?)$/;
const unitOnlyRE = /^(px|[sld]?v[wh])$/i;
const unitOnlyMap = {
  px: 1,
  vw: 100,
  vh: 100,
  svw: 100,
  svh: 100,
  dvw: 100,
  dvh: 100,
  lvh: 100,
  lvw: 100
};
const bracketTypeRe = /^\[(color|image|length|size|position|quoted|string):/i;
const splitComma = /,(?![^()]*\))/g;

const cssProps = [
  // basic props
  "color",
  "border-color",
  "background-color",
  "outline-color",
  "text-decoration-color",
  "flex-grow",
  "flex",
  "flex-shrink",
  "caret-color",
  "font",
  "gap",
  "opacity",
  "visibility",
  "z-index",
  "font-weight",
  "zoom",
  "text-shadow",
  "transform",
  "box-shadow",
  "border",
  // positions
  "background-position",
  "left",
  "right",
  "top",
  "bottom",
  "object-position",
  // sizes
  "max-height",
  "min-height",
  "max-width",
  "min-width",
  "height",
  "width",
  "border-width",
  "margin",
  "padding",
  "outline-width",
  "outline-offset",
  "font-size",
  "line-height",
  "text-indent",
  "vertical-align",
  "border-spacing",
  "letter-spacing",
  "word-spacing",
  // enhances
  "stroke",
  "filter",
  "backdrop-filter",
  "fill",
  "mask",
  "mask-size",
  "mask-border",
  "clip-path",
  "clip",
  "border-radius"
];
function round(n) {
  return +n.toFixed(10);
}
function numberWithUnit(str) {
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (unit && !Number.isNaN(num))
    return `${round(num)}${unit}`;
}
function auto(str) {
  if (str === "auto" || str === "a")
    return "auto";
}
function rem(str) {
  if (!str)
    return;
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;
  }
}
function px(str) {
  if (unitOnlyRE.test(str))
    return `${unitOnlyMap[str]}${str}`;
  const match = str.match(numberWithUnitRE);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num))
    return unit ? `${round(num)}${unit}` : `${round(num)}px`;
}
function number(str) {
  if (!numberRE.test(str))
    return;
  const num = Number.parseFloat(str);
  if (!Number.isNaN(num))
    return round(num);
}
function percent(str) {
  if (str.endsWith("%"))
    return str;
  if (numberRE.test(str)) {
    const num = Number.parseFloat(str);
    if (!Number.isNaN(num))
      return `${round(num)}%`;
  }
}
function fraction(str) {
  if (!str)
    return;
  if (str === "full")
    return "100%";
  const [left, right] = str.split("/");
  const num = Number.parseFloat(left) / Number.parseFloat(right);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return `${round(num * 100)}%`;
  }
}
function bracketWithType(str, requiredType) {
  if (str && str.startsWith("[") && str.endsWith("]")) {
    let base;
    let hintedType;
    const match = str.match(bracketTypeRe);
    if (!match) {
      base = str.slice(1, -1);
    } else {
      if (!requiredType)
        hintedType = match[1];
      base = str.slice(match[0].length, -1);
    }
    if (!base)
      return;
    if (base === '=""')
      return;
    if (base.startsWith("--"))
      base = `var(${base})`;
    let curly = 0;
    for (const i of base) {
      if (i === "[") {
        curly += 1;
      } else if (i === "]") {
        curly -= 1;
        if (curly < 0)
          return;
      }
    }
    if (curly)
      return;
    switch (hintedType) {
      case "string":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_");
      case "quoted":
        return base.replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(["\\])/g, "\\$1").replace(/^(.+)$/, '"$1"');
    }
    return base.replace(/(url\(.*?\))/g, (v) => v.replace(/_/g, "\\_")).replace(/(^|[^\\])_/g, "$1 ").replace(/\\_/g, "_").replace(/(?:calc|clamp|max|min)\((.*)/g, (match2) => {
      const vars = [];
      return match2.replace(/var\((--.+?)[,)]/g, (match3, g1) => {
        vars.push(g1);
        return match3.replace(g1, "--un-calc");
      }).replace(/(-?\d*\.?\d(?!-\d.+[,)](?![^+\-/*])\D)(?:%|[a-z]+)?|\))([+\-/*])/g, "$1 $2 ").replace(/--un-calc/g, () => vars.shift());
    });
  }
}
function bracket(str) {
  return bracketWithType(str);
}
function bracketOfColor(str) {
  return bracketWithType(str, "color");
}
function bracketOfLength(str) {
  return bracketWithType(str, "length");
}
function bracketOfPosition(str) {
  return bracketWithType(str, "position");
}
function cssvar(str) {
  if (/^\$[^\s'"`;{}]/.test(str)) {
    const [name, defaultValue] = str.slice(1).split(",");
    return `var(--${escapeSelector(name)}${defaultValue ? `, ${defaultValue}` : ""})`;
  }
}
function time(str) {
  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0 && !unit)
      return "0s";
    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;
  }
}
function degree(str) {
  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);
  if (!match)
    return;
  const [, n, unit] = match;
  const num = Number.parseFloat(n);
  if (!Number.isNaN(num)) {
    if (num === 0)
      return "0";
    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;
  }
}
function global(str) {
  if (globalKeywords.includes(str))
    return str;
}
function properties(str) {
  if (str.split(",").every((prop) => cssProps.includes(prop)))
    return str;
}
function position(str) {
  if (["top", "left", "right", "bottom", "center"].includes(str))
    return str;
}
function none(str) {
  if (str === "none")
    return "none";
}

const valueHandlers = {
  __proto__: null,
  auto: auto,
  bracket: bracket,
  bracketOfColor: bracketOfColor,
  bracketOfLength: bracketOfLength,
  bracketOfPosition: bracketOfPosition,
  cssvar: cssvar,
  degree: degree,
  fraction: fraction,
  global: global,
  none: none,
  number: number,
  numberWithUnit: numberWithUnit,
  percent: percent,
  position: position,
  properties: properties,
  px: px,
  rem: rem,
  time: time
};

const handler = createValueHandler(valueHandlers);
const h = handler;

const CONTROL_MINI_NO_NEGATIVE = "$$mini-no-negative";
const SpecialColorKey = {
  transparent: "transparent",
  current: "currentColor"
};
function numberResolver(size, defaultValue) {
  const v = h.number(size) ?? defaultValue;
  if (v != null) {
    let num = Number(v);
    if (String(v).endsWith("%")) {
      num = Number(String(v).slice(0, -1)) / 100;
    }
    return num;
  }
}
function directionSize(propertyPrefix) {
  const spaceMap = {
    "xs": 0.75 / 0.25,
    "sm": 0.875 / 0.25,
    "lg": 1.125 / 0.25,
    "xl": 1.25 / 0.25,
    "2xl": 1.5 / 0.25,
    "3xl": 1.875 / 0.25,
    "4xl": 2.25 / 0.25,
    "5xl": 3 / 0.25,
    "6xl": 3.75 / 0.25,
    "7xl": 4.5 / 0.25,
    "8xl": 6 / 0.25,
    "9xl": 8 / 0.25
  };
  return ([_, direction, size]) => {
    let v;
    v = numberResolver(size, spaceMap[size]);
    if (v != null) {
      themeTracking("spacing");
      return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, `calc(var(--spacing) * ${v})`]);
    }
    v = h.bracket.cssvar.global.auto.fraction.rem(size);
    if (v != null) {
      return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
    }
    if (size?.startsWith("-")) {
      const _v = spaceMap[size.slice(1)];
      if (_v != null) {
        themeTracking("spacing");
        v = `calc(var(--spacing) * -${_v})`;
        return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);
      }
    }
  };
}
function splitShorthand(body, type) {
  const [front, rest] = getStringComponent(body, "[", "]", ["/", ":"]) ?? [];
  if (front != null) {
    const match = (front.match(bracketTypeRe) ?? [])[1];
    if (match == null || match === type)
      return [front, rest];
  }
}
function colorableShadows(shadows, colorVar) {
  const colored = [];
  shadows = toArray(shadows);
  for (let i = 0; i < shadows.length; i++) {
    const components = getStringComponents(shadows[i], " ", 6);
    if (!components || components.length < 3)
      return shadows;
    let isInset = false;
    const pos = components.indexOf("inset");
    if (pos !== -1) {
      components.splice(pos, 1);
      isInset = true;
    }
    let colorVarValue = "";
    const lastComp = components.at(-1);
    if (parseCssColor(components.at(0))) {
      const color = parseCssColor(components.shift());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (parseCssColor(lastComp)) {
      const color = parseCssColor(components.pop());
      if (color)
        colorVarValue = `, ${colorToString(color)}`;
    } else if (lastComp && cssVarFnRE.test(lastComp)) {
      const color = components.pop();
      colorVarValue = `, ${color}`;
    }
    colored.push(`${isInset ? "inset " : ""}${components.join(" ")} var(${colorVar}${colorVarValue})`);
  }
  return colored;
}
function colorCSSGenerator(data, property, varName, ctx) {
  if (!data)
    return;
  const { color, key, alpha } = data;
  const rawColorComment = ctx?.generator.config.envMode === "dev" && color ? ` /* ${color} */` : "";
  const css = {};
  if (color) {
    const result = [css];
    if (Object.values(SpecialColorKey).includes(color)) {
      css[property] = color;
    } else {
      const alphaKey = `--un-${varName}-opacity`;
      const value = key ? `var(--colors-${key})` : color;
      if (key) {
        themeTracking(`colors`, key);
      }
      css[alphaKey] = alpha;
      css[property] = `color-mix(in oklch, ${value} var(${alphaKey}), transparent)${rawColorComment}`;
      result.push(defineProperty(alphaKey, { syntax: "<percentage>", initialValue: "100%" }));
    }
    return result;
  }
}
function colorResolver(property, varName) {
  return ([, body], ctx) => {
    const data = parseColor(body, ctx.theme);
    if (!data)
      return;
    return colorCSSGenerator(data, property, varName, ctx);
  };
}
function parseColor(body, theme) {
  const split = splitShorthand(body, "color");
  if (!split)
    return;
  const [main, opacity] = split;
  const colors = main.replace(/([a-z])(\d)/g, "$1-$2").split(/-/g);
  const [name] = colors;
  if (!name)
    return;
  let { no, key, color } = parseThemeColor(theme, colors) ?? parseThemeColor(theme, [main]) ?? {};
  if (!color) {
    const bracket = h.bracketOfColor(main);
    const bracketOrMain = bracket || main;
    if (h.numberWithUnit(bracketOrMain))
      return;
    if (/^#[\da-f]+$/i.test(bracketOrMain))
      color = bracketOrMain;
    else if (/^hex-[\da-fA-F]+$/.test(bracketOrMain))
      color = `#${bracketOrMain.slice(4)}`;
    else if (main.startsWith("$"))
      color = h.cssvar(main);
    color = color || bracket;
  }
  return {
    opacity,
    name,
    no,
    color: color ?? SpecialColorKey[name],
    alpha: h.bracket.cssvar.percent(opacity ?? ""),
    /**
     * Key means the color is from theme object.
     */
    key,
    get cssColor() {
      return parseCssColor(this.color);
    }
  };
}
function parseThemeColor(theme, keys) {
  let color;
  let no;
  let key;
  let _keys = keys;
  const [scale] = keys.slice(-1);
  if (/^\d+$/.test(scale)) {
    no = scale;
    _keys = keys.slice(0, -1);
  }
  const colorData = getThemeColor(theme, _keys);
  if (typeof colorData === "object") {
    color = colorData[no ?? "400"];
    key = [..._keys, no ?? "400"].join("-");
  } else if (typeof colorData === "string" && !no) {
    color = colorData;
    key = _keys.join("-");
  }
  if (!color)
    return;
  return {
    color,
    no,
    key
  };
}
function getThemeColor(theme, keys) {
  let obj = theme.colors;
  let index = -1;
  for (const k of keys) {
    index += 1;
    if (obj && typeof obj !== "string") {
      const camel = keys.slice(index).join("-").replace(/(-[a-z])/g, (n) => n.slice(1).toUpperCase());
      if (obj[camel])
        return obj[camel];
      if (obj[k]) {
        obj = obj[k];
        continue;
      }
    }
    return void 0;
  }
  return obj;
}
function colorVariable(str, varName) {
  const colorRegex = /(#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})\b|rgb(a)?\(\s*\d+(?:\s+\d*)?\s*\d*(\s*\/\s*[\d.]+)?\s*\)|hsl(a)?\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%(\s*,\s*[\d.]+)?\s*\))/g;
  return str.replace(colorRegex, (match) => `var(--${varName}, ${match})`);
}
function hasParseableColor(color, theme) {
  return color != null && !!parseColor(color, theme)?.color;
}
const reLetters = /[a-z]+/gi;
const resolvedBreakpoints = /* @__PURE__ */ new WeakMap();
function resolveBreakpoints({ theme, generator }, key = "breakpoint") {
  const breakpoints = generator?.userConfig?.theme?.[key] || theme[key];
  if (!breakpoints)
    return void 0;
  if (resolvedBreakpoints.has(theme))
    return resolvedBreakpoints.get(theme);
  const resolved = Object.entries(breakpoints).sort((a, b) => Number.parseInt(a[1].replace(reLetters, "")) - Number.parseInt(b[1].replace(reLetters, ""))).map(([point, size]) => ({ point, size }));
  resolvedBreakpoints.set(theme, resolved);
  return resolved;
}
function resolveVerticalBreakpoints(context) {
  return resolveBreakpoints(context, "verticalBreakpoint");
}
function makeGlobalStaticRules(prefix, property) {
  return globalKeywords.map((keyword) => [`${prefix}-${keyword}`, { [property ?? prefix]: keyword }]);
}
function isCSSMathFn(value) {
  return value != null && cssMathFnRE.test(value);
}
function isSize(str) {
  if (str[0] === "[" && str.slice(-1) === "]")
    str = str.slice(1, -1);
  return cssMathFnRE.test(str) || numberWithUnitRE.test(str);
}
function transformXYZ(d, v, name) {
  const values = v.split(splitComma);
  if (d || !d && values.length === 1)
    return xyzMap[d].map((i) => [`--un-${name}${i}`, v]);
  return values.map((v2, i) => [`--un-${name}-${xyzArray[i]}`, v2]);
}
function camelize(str) {
  return str.replace(/-(\w)/g, (_, c) => c ? c.toUpperCase() : "");
}
function hyphenate(str) {
  return str.replace(/(?:^|\B)([A-Z])/g, "-$1").toLowerCase();
}
function compressCSS(css) {
  return css.trim().replace(/\s+/g, " ").replace(/\/\*[\s\S]*?\*\//g, "");
}
function defineProperty(property, options = {}) {
  const {
    syntax = "*",
    inherits = false,
    initialValue
  } = options;
  return `@property ${property} {syntax: "${syntax}";inherits: ${inherits};${initialValue != null ? `initial-value: ${initialValue};` : ""}}`;
}

export { resolveBreakpoints as A, resolveVerticalBreakpoints as B, CONTROL_MINI_NO_NEGATIVE as C, makeGlobalStaticRules as D, isCSSMathFn as E, isSize as F, transformXYZ as G, camelize as H, hyphenate as I, compressCSS as J, defineProperty as K, bracketTypeRe as L, PRESET_NAME as P, SpecialColorKey as S, themeTracking as a, h as b, cornerMap as c, directionMap as d, xyzArray as e, positionMap as f, globalKeywords as g, handler as h, insetMap as i, cssMathFnRE as j, cssVarFnRE as k, directionSize as l, colorableShadows as m, numberResolver as n, colorCSSGenerator as o, passThemeKey as p, colorResolver as q, parseColor as r, splitShorthand as s, trackedTheme as t, parseThemeColor as u, valueHandlers as v, getThemeColor as w, xyzMap as x, colorVariable as y, hasParseableColor as z };
